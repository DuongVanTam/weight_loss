---
alwaysApply: true
---


You are a senior Dart programmer with experience in the Flutter framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## Dart General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Don't leave blank lines within a function.
- One export per file.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use underscores_case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Testing

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
    - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention.

## Specific to Flutter

### Basic Principles

- Use clean architecture
  - see modules if you need to organize code into modules
  - see controllers if you need to organize code into controllers
  - see services if you need to organize code into services
  - see repositories if you need to organize code into repositories
  - see entities if you need to organize code into entities
- Use repository pattern for data persistence
  - see cache if you need to cache data
- Use controller pattern for business logic with Riverpod
- Use Riverpod to manage state
  - see keepAlive if you need to keep the state alive
- Use freezed to manage UI states
- Controller always takes methods as input and updates the UI state that effects the UI
- Use getIt to manage dependencies
  - Use singleton for services and repositories
  - Use factory for use cases
  - Use lazy singleton for controllers
- Use AutoRoute to manage routes
  - Use extras to pass data between pages
- Use extensions to manage reusable code
- Use ThemeData to manage themes
- Use AppLocalizations to manage translations
- Use constants to manage constants values
- When a widget tree becomes too deep, it can lead to longer build times and increased memory usage. Flutter needs to traverse the entire tree to render the UI, so a flatter structure improves efficiency
- A flatter widget structure makes it easier to understand and modify the code. Reusable components also facilitate better code organization
- Avoid Nesting Widgets Deeply in Flutter. Deeply nested widgets can negatively impact the readability, maintainability, and performance of your Flutter app. Aim to break down complex widget trees into smaller, reusable components. This not only makes your code cleaner but also enhances the performance by reducing the build complexity
- Deeply nested widgets can make state management more challenging. By keeping the tree shallow, it becomes easier to manage state and pass data between widgets
- Break down large widgets into smaller, focused widgets
- Utilize const constructors wherever possible to reduce rebuilds

### Testing

- Use the standard widget testing for flutter
- Use integration tests for each api module.
- ### P1: Chuẩn bị (1–10)
1. Khảo sát đối tượng người dùng
2. Chốt mục tiêu sản phẩm
3. Viết PRD
4. Thiết kế user flow
5. Vẽ wireframe sơ bộ
6. Tạo mock JSON mẫu
7. Khởi tạo project Flutter
8. Tạo config cơ bản: fonts, theme
9. Thiết lập cấu trúc thư mục
10. Cài các dependency cần thiết (go_router, riverpod, etc)

### P2: Onboarding + Form Cá Nhân Hóa (11–20)
11. Splash + Intro screen
12. Màn chọn mục tiêu luyện tập
13. Tạo form thu thập dữ liệu giảm cân
14. Tạo form tăng cân
15. Tạo form rèn cơ
16. Lưu thông tin vào model tạm
17. Hiển thị tóm tắt kế hoạch
18. Hiển thị loading → tạo kế hoạch
19. Lưu local kế hoạch
20. Chuyển đến màn chính

### P3: Giao diện luyện tập (21–35)
21. Tạo dashboard (home)
22. Màn hình "Hôm nay tập gì"
23. Hiển thị bài tập (ảnh + text + video)
24. Có nút “Bắt đầu tập” và “Đánh dấu hoàn thành”
25. Tạo trang kế hoạch tuần
26. Hiển thị lịch biểu tập
27. Trang tiến độ cá nhân (bar, lịch màu)
28. Local notification nhắc nhở
29. Lưu trạng thái tập luyện
30. Xử lý quên tập → gợi ý lặp lại

### P4: Kết nối mock data (36–40)
31. Đọc JSON bài tập từ local
32. Mapping thành models
33. Tạo service xử lý logic gợi ý theo mục tiêu
34. Cho phép cập nhật kế hoạch thủ công
35. Tạo mẫu dữ liệu tăng cân, cơ bắp

### P5: UI hoàn thiện + polish (41–45)
36. Tối ưu responsive
37. Hiệu ứng chuyển màn hình
38. Load hình ảnh (có ảnh giả định)
39. Thêm trạng thái loading / lỗi
40. Animation (splash, hoàn thành,...)

### P6: Chuẩn bị phát hành (46–50)
41. Viết README kỹ thuật
42. Tối ưu performance
43. Kiểm thử multi-device
44. Build thử APK/AAB
45. Viết landing page hoặc mô tả app
46. Tạo bản dùng thử offline
47. Thu thập feedback user thật
48. Cải tiến form + logic
49. Lên kế hoạch tích hợp API thật
50. Chuẩn bị đăng lên store
- **assets/json/workouts.json**
mock trước các json cần thiết, tích hợp với Backend sau

**Cách gọi trong Flutter:**
```dart
final data = await rootBundle.loadString('assets/json/workouts.json');
final Map<String, dynamic> jsonData = jsonDecode(data);
```
- ### Mục tiêu sản phẩm:
- Tạo lộ trình luyện tập cá nhân hóa cho người dùng theo 1 trong 3 mục tiêu: giảm cân, tăng cân, rèn luyện cơ bắp.
- Giao diện đơn giản, dễ dùng, hỗ trợ cả người mới.
- Dữ liệu bài tập được hiển thị từ mock JSON, có thể thay bằng API về sau.

### Tính năng cốt lõi (MVP):
1. Đăng nhập / Đăng ký (email, Google)
2. Chọn mục tiêu tập luyện
3. Điền thông tin cá nhân & thói quen
4. App tạo kế hoạch luyện tập hằng tuần
5. Giao diện bài tập hằng ngày (hình ảnh + hướng dẫn)
6. Theo dõi tiến độ
7. Bộ nhắc tập (notification local)
8. Giao diện responsive đẹp, thân thiện
- **Cấu trúc thư mục Flutter:**
```
lib/
├── main.dart
├── features/
│   ├── onboarding/
│   ├── auth/
│   ├── planner/
│   ├── workout/
│   └── profile/
├── models/
├── services/
│   └── json_loader.dart
├── data/
│   └── mock/
│       └── workouts.json
├── shared/
│   ├── widgets/
│   └── styles/
```
- | Layer              | Stack dùng                                                                 |
|-----|----|
| **Frontend**        | Flutter 3.x + Riverpod (state management) + GoRouter (navigation)          |
| **Mock backend**    | Dữ liệu local JSON (tạm thời) lưu trong assets/json/                      |
| **Sau này API**     | REST API (NestJS hoặc Supabase)                                           |
| **Media**           | Hình ảnh/video minh họa lưu trên Cloudinary hoặc local tạm                |
| **Local DB**        | Hive hoặc SharedPreferences                                               |
| **Notification**    | flutter_local_notifications (nhắc lịch tập)                              |
- [Splash Screen]
    ↓
[Onboarding Giới thiệu App]
    ↓
[Chọn Mục Tiêu Tập Luyện]
    ↓
[Form Cá Nhân Hóa theo mục tiêu]
    ↓
[Tóm tắt kế hoạch → Bắt đầu]
    ↓
[Màn hình chính (Dashboard)]
    ├── Hôm nay tập gì?
    ├── Xem toàn bộ kế hoạch tuần
    ├── Tiến độ cá nhân
    └── Cài đặt cá nhân
    
- Use the standard widget testing for flutter
- Use integration tests for each api module.
    
You are a senior Dart programmer with experience in the Flutter framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## Dart General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using any.
  - Create necessary types.
- Don't leave blank lines within a function.
- One export per file.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use underscores_case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Testing

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: inputX, mockX, actualX, expectedX, etc.
- Write unit tests for each public function.
  - Use test doubles to simulate dependencies.
    - Except for third-party dependencies that are not expensive to execute.
- Write acceptance tests for each module.
  - Follow the Given-When-Then convention.

## Specific to Flutter

### Basic Principles

- Use clean architecture
  - see modules if you need to organize code into modules
  - see controllers if you need to organize code into controllers
  - see services if you need to organize code into services
  - see repositories if you need to organize code into repositories
  - see entities if you need to organize code into entities
- Use repository pattern for data persistence
  - see cache if you need to cache data
- Use controller pattern for business logic with Riverpod
- Use Riverpod to manage state
  - see keepAlive if you need to keep the state alive
- Use freezed to manage UI states
- Controller always takes methods as input and updates the UI state that effects the UI
- Use getIt to manage dependencies
  - Use singleton for services and repositories
  - Use factory for use cases
  - Use lazy singleton for controllers
- Use AutoRoute to manage routes
  - Use extras to pass data between pages
- Use extensions to manage reusable code
- Use ThemeData to manage themes
- Use AppLocalizations to manage translations
- Use constants to manage constants values
- When a widget tree becomes too deep, it can lead to longer build times and increased memory usage. Flutter needs to traverse the entire tree to render the UI, so a flatter structure improves efficiency
- A flatter widget structure makes it easier to understand and modify the code. Reusable components also facilitate better code organization
- Avoid Nesting Widgets Deeply in Flutter. Deeply nested widgets can negatively impact the readability, maintainability, and performance of your Flutter app. Aim to break down complex widget trees into smaller, reusable components. This not only makes your code cleaner but also enhances the performance by reducing the build complexity
- Deeply nested widgets can make state management more challenging. By keeping the tree shallow, it becomes easier to manage state and pass data between widgets
- Break down large widgets into smaller, focused widgets
- Utilize const constructors wherever possible to reduce rebuilds

### Testing

- Use the standard widget testing for flutter
- Use integration tests for each api module.
- ### P1: Chuẩn bị (1–10)
1. Khảo sát đối tượng người dùng
2. Chốt mục tiêu sản phẩm
3. Viết PRD
4. Thiết kế user flow
5. Vẽ wireframe sơ bộ
6. Tạo mock JSON mẫu
7. Khởi tạo project Flutter
8. Tạo config cơ bản: fonts, theme
9. Thiết lập cấu trúc thư mục
10. Cài các dependency cần thiết (go_router, riverpod, etc)

### P2: Onboarding + Form Cá Nhân Hóa (11–20)
11. Splash + Intro screen
12. Màn chọn mục tiêu luyện tập
13. Tạo form thu thập dữ liệu giảm cân
14. Tạo form tăng cân
15. Tạo form rèn cơ
16. Lưu thông tin vào model tạm
17. Hiển thị tóm tắt kế hoạch
18. Hiển thị loading → tạo kế hoạch
19. Lưu local kế hoạch
20. Chuyển đến màn chính

### P3: Giao diện luyện tập (21–35)
21. Tạo dashboard (home)
22. Màn hình "Hôm nay tập gì"
23. Hiển thị bài tập (ảnh + text + video)
24. Có nút “Bắt đầu tập” và “Đánh dấu hoàn thành”
25. Tạo trang kế hoạch tuần
26. Hiển thị lịch biểu tập
27. Trang tiến độ cá nhân (bar, lịch màu)
28. Local notification nhắc nhở
29. Lưu trạng thái tập luyện
30. Xử lý quên tập → gợi ý lặp lại

### P4: Kết nối mock data (36–40)
31. Đọc JSON bài tập từ local
32. Mapping thành models
33. Tạo service xử lý logic gợi ý theo mục tiêu
34. Cho phép cập nhật kế hoạch thủ công
35. Tạo mẫu dữ liệu tăng cân, cơ bắp

### P5: UI hoàn thiện + polish (41–45)
36. Tối ưu responsive
37. Hiệu ứng chuyển màn hình
38. Load hình ảnh (có ảnh giả định)
39. Thêm trạng thái loading / lỗi
40. Animation (splash, hoàn thành,...)

### P6: Chuẩn bị phát hành (46–50)
41. Viết README kỹ thuật
42. Tối ưu performance
43. Kiểm thử multi-device
44. Build thử APK/AAB
45. Viết landing page hoặc mô tả app
46. Tạo bản dùng thử offline
47. Thu thập feedback user thật
48. Cải tiến form + logic
49. Lên kế hoạch tích hợp API thật
50. Chuẩn bị đăng lên store
- **assets/json/workouts.json**
mock trước các json cần thiết, tích hợp với Backend sau

**Cách gọi trong Flutter:**
```dart
final data = await rootBundle.loadString('assets/json/workouts.json');
final Map<String, dynamic> jsonData = jsonDecode(data);
```
- ### Mục tiêu sản phẩm:
- Tạo lộ trình luyện tập cá nhân hóa cho người dùng theo 1 trong 3 mục tiêu: giảm cân, tăng cân, rèn luyện cơ bắp.
- Giao diện đơn giản, dễ dùng, hỗ trợ cả người mới.
- Dữ liệu bài tập được hiển thị từ mock JSON, có thể thay bằng API về sau.

### Tính năng cốt lõi (MVP):
1. Đăng nhập / Đăng ký (email, Google)
2. Chọn mục tiêu tập luyện
3. Điền thông tin cá nhân & thói quen
4. App tạo kế hoạch luyện tập hằng tuần
5. Giao diện bài tập hằng ngày (hình ảnh + hướng dẫn)
6. Theo dõi tiến độ
7. Bộ nhắc tập (notification local)
8. Giao diện responsive đẹp, thân thiện
- **Cấu trúc thư mục Flutter:**
```
lib/
├── main.dart
├── features/
│   ├── onboarding/
│   ├── auth/
│   ├── planner/
│   ├── workout/
│   └── profile/
├── models/
├── services/
│   └── json_loader.dart
├── data/
│   └── mock/
│       └── workouts.json
├── shared/
│   ├── widgets/
│   └── styles/
```
- | Layer              | Stack dùng                                                                 |
|-----|----|
| **Frontend**        | Flutter 3.x + Riverpod (state management) + GoRouter (navigation)          |
| **Mock backend**    | Dữ liệu local JSON (tạm thời) lưu trong assets/json/                      |
| **Sau này API**     | REST API (NestJS hoặc Supabase)                                           |
| **Media**           | Hình ảnh/video minh họa lưu trên Cloudinary hoặc local tạm                |
| **Local DB**        | Hive hoặc SharedPreferences                                               |
| **Notification**    | flutter_local_notifications (nhắc lịch tập)                              |
- [Splash Screen]
    ↓
[Onboarding Giới thiệu App]
    ↓
[Chọn Mục Tiêu Tập Luyện]
    ↓
[Form Cá Nhân Hóa theo mục tiêu]
    ↓
[Tóm tắt kế hoạch → Bắt đầu]
    ↓
[Màn hình chính (Dashboard)]
    ├── Hôm nay tập gì?
    ├── Xem toàn bộ kế hoạch tuần
    ├── Tiến độ cá nhân
    └── Cài đặt cá nhân
    
- Use the standard widget testing for flutter
- Use integration tests for each api module.
    